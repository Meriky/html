  <h4>语法错误</h4>

  <!-- NON-NORMATIVE SECTION -->

  <p>限制 HTML 的语法是为了避免各种各样的问题。</p>

  <dl>

   <dt>不直观的错误处理行为</dt>

   <dd>

    <p>某些不合法的语法构造在解析后会导致很不直观的 DOM 树。</p>

    <div class="example">

     <p>例如，以下标记片段会导致 DOM 树中的 <code>hr</code> 元素
     在相应的 <code>table</code> 元素<em>之前</em>。</p>

     <pre class="bad">&lt;table>&lt;hr>...</pre>

    </div>

   </dd>


   <dt>可选错误恢复的错误</dt>

   <dd>

    <p>为了允许在受控环境中使用的用户代理不必实现更奇怪和复杂的错误处理规则，
    允许用户代理在遇到<span data-x="parse error">解析错误</span>时失败。</p>

   </dd>


   <dt>错误处理行为与流式用户代理不兼容的的错误</dt>

   <dd>

    <p>一些错误处理行为（比如上面提到的<code data-x="">&lt;table>&lt;hr>...</code>）
    与流式用户代理（不存储状态且通过一次遍历来处理 HTML 文件的用户代理）不兼容。
    为了避免与这样的用户代理的互操作性问题，任何导致该行为的语法都是无效的。</p>

   </dd>


   <dt>会导致信息集强制的错误</dt>

   <dd>

    <p>当一个基于 XML 的用户代理连接到一个 HTML 解析器时，
    某些 XML 强制的不变式（比如元素或属性名不可包含多个冒号）可能被 HTML 文件违反。
    处理这种情况可能要求解析器将 HTML DOM 信息强加给 XML 兼容的信息集。
    要求这一处理的多数语法构造都是不合法的。
    （包含两个连续的间隔符的注释，或以一个间隔符结尾的注释是特例，这在 HTML 语法中是允许的）。</p>
    <p class="comment">译注：这一规则意味着基于 XML 的用户代理只需连接一个 HTML
    解析器（Parser）即可拥有理解 HTML 的能力。所以 HTML 与 XML 只是语法有所不同，
    表达语义的能力应当是等价的。</p>

   </dd>


   <dt>Errors that result in disproportionately poor performance</dt>

   <dd>

    <p>Certain syntax constructs can result in disproportionately poor performance. To discourage the
    use of such constructs, they are typically made non-conforming.</p>

    <div class="example">

     <p>For example, the following markup results in poor performance, since all the unclosed
     <code>i</code> elements have to be reconstructed in each paragraph, resulting in progressively
     more elements in each paragraph:</p>

     <pre class="bad">&lt;p>&lt;i>She dreamt.
&lt;p>&lt;i>She dreamt that she ate breakfast.
&lt;p>&lt;i>Then lunch.
&lt;p>&lt;i>And finally dinner.</pre>

     <p>The resulting DOM for this fragment would be:</p>

     <ul class="domTree"><li class="t1"><code>p</code><ul><li class="t1"><code>i</code><ul><li class="t3"><code>#text</code>: <span data-x="">She dreamt.</span></li></ul></li></ul></li><li class="t1"><code>p</code><ul><li class="t1"><code>i</code><ul><li class="t1"><code>i</code><ul><li class="t3"><code>#text</code>: <span data-x="">She dreamt that she ate breakfast.</span></li></ul></li></ul></li></ul></li><li class="t1"><code>p</code><ul><li class="t1"><code>i</code><ul><li class="t1"><code>i</code><ul><li class="t1"><code>i</code><ul><li class="t3"><code>#text</code>: <span data-x="">Then lunch.</span></li></ul></li></ul></li></ul></li></ul></li><li class="t1"><code>p</code><ul><li class="t1"><code>i</code><ul><li class="t1"><code>i</code><ul><li class="t1"><code>i</code><ul><li class="t1"><code>i</code><ul><li class="t3"><code>#text</code>: <span data-x="">And finally dinner.</span></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>

    </div>

   </dd>


   <dt>Errors involving fragile syntax constructs</dt>

   <dd>

    <p>There are syntax constructs that, for historical reasons, are relatively fragile. To help
    reduce the number of users who accidentally run into such problems, they are made
    non-conforming.</p>

    <div class="example">

     <p>For example, the parsing of certain named character references in attributes happens even
     with the closing semicolon being omitted. It is safe to include an ampersand followed by
     letters that do not form a named character reference, but if the letters are changed to a
     string that <em>does</em> form a named character reference, they will be interpreted as that
     character instead.</p>

     <p>In this fragment, the attribute's value is "<code data-x="">?bill&amp;ted</code>":</p>

     <pre class="bad">&lt;a href="?bill&amp;ted">Bill and Ted&lt;/a></pre>

     <p>In the following fragment, however, the attribute's value is actually "<code
     data-x="">?art&copy;</code>", <em>not</em> the intended "<code data-x="">?art&amp;copy</code>",
     because even without the final semicolon, "<code data-x="">&amp;copy</code>" is handled the same
     as "<code data-x="">&amp;copy;</code>" and thus gets interpreted as "<code
     data-x="">&copy;</code>":</p>

     <pre class="bad">&lt;a href="?art&amp;copy">Art and Copy&lt;/a></pre>

     <p>To avoid this problem, all named character references are required to end with a semicolon,
     and uses of named character references without a semicolon are flagged as errors.</p>

     <p>Thus, the correct way to express the above cases is as
     follows:</p>

     <pre>&lt;a href="?bill&amp;ted">Bill and Ted&lt;/a> &lt;!-- &amp;ted is ok, since it's not a named character reference --></pre>
     <pre>&lt;a href="?art&amp;amp;copy">Art and Copy&lt;/a> &lt;!-- the &amp; has to be escaped, since &amp;copy <em>is</em> a named character reference --></pre>

    </div>

   </dd>


   <dt>Errors involving known interoperability problems in legacy user agents</dt>

   <dd>

    <p>Certain syntax constructs are known to cause especially subtle or serious problems in legacy
    user agents, and are therefore marked as non-conforming to help authors avoid them.</p>

    <div class="example">

     <p>For example, this is why the U+0060 GRAVE ACCENT character (`) is not allowed in unquoted
     attributes. In certain legacy user agents, <!-- namely IE --> it is sometimes treated as a
     quote character.</p>

    </div>

    <div class="example">

     <p>Another example of this is the DOCTYPE, which is required to trigger <span>no-quirks
     mode</span>, because the behavior of legacy user agents in <span>quirks mode</span> is often
     largely undocumented.</p>

    </div>

   </dd>


<!--ADD-TOPIC:Security-->
   <dt>Errors that risk exposing authors to security attacks</dt>

   <dd>

    <p>Certain restrictions exist purely to avoid known security problems.</p>

    <div class="example">

     <p>For example, the restriction on using UTF-7 exists purely to avoid authors falling prey to a
     known cross-site-scripting attack using UTF-7. <ref spec=UTF7></p>

    </div>

   </dd>
<!--REMOVE-TOPIC:Security-->


   <dt>Cases where the author's intent is unclear</dt>

   <dd>

    <p>Markup where the author's intent is very unclear is often made non-conforming. Correcting
    these errors early makes later maintenance easier.</p>

    <div class="example">

     <p>For example, it is unclear whether the author intended the following to be an
     <code>h1</code> heading or an <code>h2</code> heading:</p>

     <pre class="bad">&lt;h1>Contact details&lt;/h2></pre>

    </div>

   </dd>


   <dt>Cases that are likely to be typos</dt>

   <dd>

    <p>When a user makes a simple typo, it is helpful if the error can be caught early, as this can
    save the author a lot of debugging time. This specification therefore usually considers it an
    error to use element names, attribute names, and so forth, that do not match the names defined
    in this specification.</p>

    <div class="example">

     <p>For example, if the author typed <code data-x="">&lt;capton></code> instead of <code
     data-x="">&lt;caption></code>, this would be flagged as an error and the author could correct
     the typo immediately.</p>

    </div>

   </dd>


   <dt>Errors that could interfere with new syntax in the future</dt>

   <dd>

    <p>In order to allow the language syntax to be extended in the future, certain otherwise
    harmless features are disallowed.</p>

    <div class="example">

     <p>For example, "attributes" in end tags are ignored currently, but they are invalid, in case a
     future change to the language makes use of that syntax feature without conflicting with
     already-deployed (and valid!) content.</p>

    </div>

   </dd>


  </dl>

  <p>Some authors find it helpful to be in the practice of always quoting all attributes and always
  including all optional tags, preferring the consistency derived from such custom over the minor
  benefits of terseness afforded by making use of the flexibility of the HTML syntax. To aid such
  authors, conformance checkers can provide modes of operation wherein such conventions are
  enforced.</p>



